#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <thread>
#include <chrono>
#include <filesystem>
#include <algorithm>
#include <limits>
#include <conio.h>

using namespace std;
namespace fs = filesystem;

/// <summary>
/// Получить содержимое файла
/// </summary>
/// <param name="filename">Имя считываемого файла</param>
/// <returns>Содержимое файла</returns>
string getFileContent(string filename)
{
    ifstream file(filename);
    if (!file.is_open()) {
        cout << "Error open file";
        return "";
    }

    string content(
        (istreambuf_iterator<char>(file)),
        istreambuf_iterator<char>());
    file.close();
    return content;
}

/// <summary>
/// Разделить строку на части по разделителю
/// </summary>
/// <param name="content">Исходная строка</param>
/// <param name="delimeter">Разделитель</param>
/// <returns>Вектор с частями строки</returns>
vector<string> split(string content, string delimeter)
{
    vector<string> parts;
    int start = 0;
    int end = content.find(delimeter);

    while (end != string::npos)
    {
        parts.push_back(content.substr(start, end - start));
        start = end + delimeter.length();
        end = content.find(delimeter, start);
    }
    parts.push_back(content.substr(start));
    return parts;
}

/// <summary>
/// Получить список файлов анимаций из текущей директории
/// </summary>
/// <returns>Вектор с именами файлов анимаций</returns>
vector<string> getAnimationFiles()
{
    vector<string> animationFiles;

    try {
        for (const auto& entry : fs::directory_iterator(".")) {
            if (entry.is_regular_file()) {
                string filename = entry.path().filename().string();

                // Проверяем критерии: начинается на "animation" и имеет расширение ".txt"
                if (filename.find("animation") == 0 &&
                    entry.path().extension() == ".txt") {
                    animationFiles.push_back(filename);
                }
            }
        }

        // Сортируем файлы для удобства
        sort(animationFiles.begin(), animationFiles.end());
    }
    catch (const fs::filesystem_error& e) {
        cout << "Error accessing directory: " << e.what() << endl;
    }

    return animationFiles;
}

/// <summary>
/// Воспроизвести анимацию из файла
/// </summary>
/// <param name="filename">Имя файла с анимацией</param>
/// <param name="loop">true - зацикленное проигрывание, false - один раз</param>
void playAnimation(string filename, bool loop = false)
{
    string content = getFileContent(filename);
    if (content.empty()) {
        cout << "Failed to load animation: " << filename << endl;
        cout << "Press any key to continue..." << endl;
        cin.get();
        return;
    }

    vector<string> frames = split(content, "FRAME");

    cout << "\nPlaying animation: " << filename << endl;
    cout << "Mode: " << (loop ? "Looping" : "Play once") << endl;
    cout << "Press any key to stop..." << endl;
    this_thread::sleep_for(chrono::seconds(1));

    do {
        for (string frame : frames) {
            // Проверяем, не нажата ли клавиша
            if (_kbhit()) {
                _getch(); // Считываем нажатую клавишу
                return;
            }

            system("cls");
            cout << frame << endl;
            this_thread::sleep_for(chrono::milliseconds(100));
        }
    } while (loop); // Повторяем только если loop = true
}

/// <summary>
/// Отобразить главное меню выбора анимации
/// </summary>
/// <param name="animationFiles">Список файлов анимаций</param>
void displayMainMenu(const vector<string>& animationFiles)
{
    cout << "=== ANIMATION PLAYER ===" << endl;
    cout << "Select an animation to play:" << endl;

    // Выводим нумерованный список анимаций
    for (size_t i = 0; i < animationFiles.size(); i++) {
        cout << i + 1 << ". " << animationFiles[i] << endl;
    }

    // Добавляем пункт для выхода
    cout << animationFiles.size() + 1 << ". Exit" << endl;
    cout << "=========================" << endl;
    cout << "Enter your choice (1-" << animationFiles.size() + 1 << "): ";
}

/// <summary>
/// Отобразить меню выбора режима проигрывания
/// </summary>
/// <param name="filename">Имя выбранного файла анимации</param>
void displayPlaybackMenu(string filename)
{
    system("cls");
    cout << "=== PLAYBACK MODE ===" << endl;
    cout << "Selected: " << filename << endl;
    cout << "1. Play once" << endl;
    cout << "2. Loop continuously" << endl;
    cout << "3. Back to main menu" << endl;
    cout << "=====================" << endl;
    cout << "Enter your choice (1-3): ";
}

/// <summary>
/// Очистить буфер ввода
/// </summary>
void clearInputBuffer()
{
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

/// <summary>
/// Основная функция приложения
/// </summary>
/// <returns>Код завершения программы</returns>
int main()
{
    // Получаем список файлов анимаций
    vector<string> animationFiles = getAnimationFiles();

    if (animationFiles.empty()) {
        cout << "No animation files found!" << endl;
        cout << "Please make sure you have files starting with 'animation' and .txt extension" << endl;
        cout << "Press any key to exit..." << endl;
        cin.get();
        return 1;
    }

    int choice;
    bool running = true;

    while (running) {
        // Очищаем экран и показываем главное меню
        system("cls");
        displayMainMenu(animationFiles);

        // Получаем выбор пользователя
        if (!(cin >> choice)) {
            cout << "Invalid input! Please enter a number." << endl;
            clearInputBuffer();
            this_thread::sleep_for(chrono::seconds(1));
            continue;
        }

        // Проверяем валидность выбора
        if (choice == animationFiles.size() + 1) {
            cout << "Goodbye!" << endl;
            running = false;
            break;
        }
        else if (choice >= 1 && choice <= animationFiles.size()) {
            string selectedFile = animationFiles[choice - 1];
            int playbackChoice;

            // Показываем меню выбора режима проигрывания
            while (true) {
                displayPlaybackMenu(selectedFile);

                if (!(cin >> playbackChoice)) {
                    cout << "Invalid input! Please enter a number." << endl;
                    clearInputBuffer();
                    this_thread::sleep_for(chrono::seconds(1));
                    continue;
                }

                if (playbackChoice == 1) {
                    // Проиграть один раз
                    playAnimation(selectedFile, false);
                    break;
                }
                else if (playbackChoice == 2) {
                    // Зацикленное проигрывание
                    playAnimation(selectedFile, true);
                    break;
                }
                else if (playbackChoice == 3) {
                    // Вернуться в главное меню
                    break;
                }
                else {
                    cout << "Invalid choice! Please try again." << endl;
                    this_thread::sleep_for(chrono::seconds(1));
                }

                clearInputBuffer();
            }
        }
        else {
            cout << "Invalid choice! Please try again." << endl;
            this_thread::sleep_for(chrono::seconds(1));
        }

        // Очищаем буфер ввода
        clearInputBuffer();
    }

    return 0;
}
